# LeetCode Problems Summary

This file provides a brief overview of the LeetCode problems implemented in this project.

---

### #1. Two Sum
**Problem:** Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`.

### #15. 3Sum
**Problem:** Given an integer array `nums`, return all unique triplets `[nums[i], nums[j], nums[k]]` such that `i != j != k` and their sum is `0`.

### #19. Remove Nth Node From End of List
**Problem:** Given the `head` of a linked list, remove the `n`-th node from the end of the list and return its head.

### #27. Remove Element
**Problem:** Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place and return the number of elements remaining.

### #42. Trapping Rain Water
**Problem:** Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

### #28. Find the Index of the First Occurrence in a String
**Problem:** Given two strings, `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.

### #59. Spiral Matrix II
**Problem:** Given a positive integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in spiral order.

### #142. Linked List Cycle II
**Problem:** Given the `head` of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.

### #151. Reverse Words in a String
**Problem:** Given an input string `s`, reverse the order of the words. The returned string should have a single space separating the words, with no extra spaces.

### #203. Remove Linked List Elements
**Problem:** Given the `head` of a linked list and an integer `val`, remove all nodes of the linked list that have `Node.val == val`, and return the new head.

### #206. Reverse Linked List
**Problem:** Given the `head` of a singly linked list, reverse the list and return the reversed list.

### #209. Minimum Size Subarray Sum
**Problem:** Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a subarray whose sum is greater than or equal to `target`. If no such subarray exists, return `0`.

### #242. Valid Anagram
**Problem:** Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

### #344. Reverse String
**Problem:** Write a a function that reverses a string. The input string is given as an array of characters `s`. You must do this by modifying the input array in-place with O(1) extra memory.

### #349. Intersection of Two Arrays
**Problem:** Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique.

### #452. Minimum Number of Arrows to Burst Balloons
**Problem:** Given an array of points where `points[i] = [xstart, xend]`, return the minimum number of arrows that must be shot to burst all balloons. An arrow shot at `x` bursts a balloon if `xstart <= x <= end`.

### #454. 4Sum II
**Problem:** Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4`, return the number of tuples `(i, j, k, l)` such that `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`.

### #541. Reverse String II
**Problem:** Given a string `s` and an integer `k`, for every `2k` characters, reverse the first `k` characters. Handle edge cases with remaining characters.

### #707. Design Linked List
**Problem:** Design and implement a `MyLinkedList` class that supports `get`, `addAtHead`, `addAtTail`, `addAtIndex`, and `deleteAtIndex` operations for both singly and doubly linked lists.

### #459. Repeated Substring Pattern
**Problem:** Given a non-empty string `s`, determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

### #232. Implement Queue using Stacks
**Problem:** Implement a First-In-First-Out (FIFO) queue using only two stacks. The implemented queue must support all the standard queue operations: `push`, `pop`, `peek`, and `empty`.

### #225. Implement Stack using Queues
**Problem:** Implement a Last-In-First-Out (LIFO) stack using only one or two queues. The implemented stack must support all the standard stack operations: `push`, `top`, `pop`, and `empty`.

### #20. Valid Parentheses
**Problem:** Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets and in the correct order.

### #150. Evaluate Reverse Polish Notation
**Problem:** Given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation, evaluate the expression and return its integer value. The valid operators are `+`, `-`, `*`, `/`, and division truncates toward zero.

### #145. Binary Tree Postorder Traversal
**Problem:** Given the `root` of a binary tree, return the postorder traversal of its nodes' values.

### #239. Sliding Window Maximum
**Problem:** You are given an array of integers `nums` and an integer `k`. A sliding window of size `k` moves from the very left to the very right of the array. Return an array of the maximum values found in each window.

### #347. Top K Frequent Elements
**Problem:** Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

### #94. Binary Tree Inorder Traversal
**Problem:** Given the `root` of a binary tree, return the inorder traversal of its nodes' values.

### #144. Binary Tree Preorder Traversal
**Problem:** Given the `root` of a binary tree, return the preorder traversal of its nodes' values.

### #102. Binary Tree Level Order Traversal
**Problem:** Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

### #101. Symmetric Tree
**Problem:** Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

### #104. Maximum Depth of Binary Tree
**Problem:** Given the `root` of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

### #111. Minimum Depth of Binary Tree
**Problem:** Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children.

### #226. Invert Binary Tree
**Problem:** Given the `root` of a binary tree, invert the tree, and return its root. Inverting a binary tree means swapping every node's left and right children recursively throughout the tree.

### #110. Balanced Binary Tree
**Problem:** Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.

### #257. Binary Tree Paths
**Problem:** Given the `root` of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.

### #105. Construct Binary Tree from Preorder and Inorder Traversal
**Problem:** Given two integer arrays `preorder` and `inorder`, where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.

### #106. Construct Binary Tree from Inorder and Postorder Traversal
**Problem:** Given two integer arrays `inorder` and `postorder`, where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return the binary tree.

### #112. Path Sum
**Problem:** Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a root-to-leaf path such that the sum of all values along the path equals `targetSum`. A leaf is a node with no children.

### #617. Merge Two Binary Trees
**Problem:** You are given two binary trees, `root1` and `root2`. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is:
- If two nodes overlap, sum their values as the new value of the merged node.
- Otherwise, the non-null node becomes the node of the new tree.
Return the merged tree. Note that the merging process must start from the root nodes of both trees.

### #700. Search in a Binary Search Tree
**Problem:** You are given the `root` of a binary search tree (BST) and an integer `val`. Find the node in the BST that has the value equal to `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.

### #98. Validate Binary Search Tree
**Problem:** Given the `root` of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows:
- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- Both the left and right subtrees must also be binary search trees.

### #530. Minimum Absolute Difference in BST
**Problem:** Given the `root` of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.

### #501. Find Mode in Binary Search Tree
**Problem:** Given the `root` of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order.

### #236. Lowest Common Ancestor of a Binary Tree
**Problem:** Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: "The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself)."

### #701. Insert into a Binary Search Tree
**Problem:** You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

There may be multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

### #450. Delete Node in a BST
**Problem:** Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

### #108. Convert Sorted Array to Binary Search Tree
**Problem:** Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.

### #669. Trim a Binary Search Tree
**Problem:** Given the `root` of a binary search tree and the lowest and highest boundaries as `low` and `high`, trim the tree so that all its elements lie in `[low, high]`. Trimming the tree should not change the relative structure of the elements that remain in the tree. Return the root of the trimmed binary search tree.
