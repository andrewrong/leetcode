# LeetCode Problems Summary

This file provides a brief overview of the LeetCode problems implemented in this project.

---

### #1. Two Sum
**Problem:** Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`.

### #15. 3Sum
**Problem:** Given an integer array `nums`, return all unique triplets `[nums[i], nums[j], nums[k]]` such that `i != j != k` and their sum is `0`.

### #19. Remove Nth Node From End of List
**Problem:** Given the `head` of a linked list, remove the `n`-th node from the end of the list and return its head.

### #27. Remove Element
**Problem:** Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place and return the number of elements remaining.

### #42. Trapping Rain Water
**Problem:** Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

### #28. Find the Index of the First Occurrence in a String
**Problem:** Given two strings, `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.

### #59. Spiral Matrix II
**Problem:** Given a positive integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in spiral order.

### #142. Linked List Cycle II
**Problem:** Given the `head` of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.

### #151. Reverse Words in a String
**Problem:** Given an input string `s`, reverse the order of the words. The returned string should have a single space separating the words, with no extra spaces.

### #203. Remove Linked List Elements
**Problem:** Given the `head` of a linked list and an integer `val`, remove all nodes of the linked list that have `Node.val == val`, and return the new head.

### #206. Reverse Linked List
**Problem:** Given the `head` of a singly linked list, reverse the list and return the reversed list.

### #209. Minimum Size Subarray Sum
**Problem:** Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a subarray whose sum is greater than or equal to `target`. If no such subarray exists, return `0`.

### #242. Valid Anagram
**Problem:** Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

### #344. Reverse String
**Problem:** Write a a function that reverses a string. The input string is given as an array of characters `s`. You must do this by modifying the input array in-place with O(1) extra memory.

### #349. Intersection of Two Arrays
**Problem:** Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique.

### #452. Minimum Number of Arrows to Burst Balloons
**Problem:** Given an array of points where `points[i] = [xstart, xend]`, return the minimum number of arrows that must be shot to burst all balloons. An arrow shot at `x` bursts a balloon if `xstart <= x <= end`.

### #454. 4Sum II
**Problem:** Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4`, return the number of tuples `(i, j, k, l)` such that `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`.

### #541. Reverse String II
**Problem:** Given a string `s` and an integer `k`, for every `2k` characters, reverse the first `k` characters. Handle edge cases with remaining characters.

### #707. Design Linked List
**Problem:** Design and implement a `MyLinkedList` class that supports `get`, `addAtHead`, `addAtTail`, `addAtIndex`, and `deleteAtIndex` operations for both singly and doubly linked lists.

### #459. Repeated Substring Pattern
**Problem:** Given a non-empty string `s`, determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

### #232. Implement Queue using Stacks
**Problem:** Implement a First-In-First-Out (FIFO) queue using only two stacks. The implemented queue must support all the standard queue operations: `push`, `pop`, `peek`, and `empty`.

### #225. Implement Stack using Queues
**Problem:** Implement a Last-In-First-Out (LIFO) stack using only one or two queues. The implemented stack must support all the standard stack operations: `push`, `top`, `pop`, and `empty`.

### #20. Valid Parentheses
**Problem:** Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets and in the correct order.

### #150. Evaluate Reverse Polish Notation
**Problem:** Given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation, evaluate the expression and return its integer value. The valid operators are `+`, `-`, `*`, `/`, and division truncates toward zero.

### #145. Binary Tree Postorder Traversal
**Problem:** Given the `root` of a binary tree, return the postorder traversal of its nodes' values.

### #239. Sliding Window Maximum
**Problem:** You are given an array of integers `nums` and an integer `k`. A sliding window of size `k` moves from the very left to the very right of the array. Return an array of the maximum values found in each window.

### #347. Top K Frequent Elements
**Problem:** Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

### #94. Binary Tree Inorder Traversal
**Problem:** Given the `root` of a binary tree, return the inorder traversal of its nodes' values.

### #144. Binary Tree Preorder Traversal
**Problem:** Given the `root` of a binary tree, return the preorder traversal of its nodes' values.

### #102. Binary Tree Level Order Traversal
**Problem:** Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

### #101. Symmetric Tree
**Problem:** Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

### #104. Maximum Depth of Binary Tree
**Problem:** Given the `root` of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

### #111. Minimum Depth of Binary Tree
**Problem:** Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children.

### #226. Invert Binary Tree
**Problem:** Given the `root` of a binary tree, invert the tree, and return its root. Inverting a binary tree means swapping every node's left and right children recursively throughout the tree.

### #110. Balanced Binary Tree
**Problem:** Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.

### #257. Binary Tree Paths
**Problem:** Given the `root` of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.

### #105. Construct Binary Tree from Preorder and Inorder Traversal
**Problem:** Given two integer arrays `preorder` and `inorder`, where `preorder` is the preorder traversal of a binary tree and `inorder` is the inorder traversal of the same tree, construct and return the binary tree.

### #106. Construct Binary Tree from Inorder and Postorder Traversal
**Problem:** Given two integer arrays `inorder` and `postorder`, where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return the binary tree.

### #112. Path Sum
**Problem:** Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a root-to-leaf path such that the sum of all values along the path equals `targetSum`. A leaf is a node with no children.

### #617. Merge Two Binary Trees
**Problem:** You are given two binary trees, `root1` and `root2`. Imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge the two trees into a new binary tree. The merge rule is:
- If two nodes overlap, sum their values as the new value of the merged node.
- Otherwise, the non-null node becomes the node of the new tree.
Return the merged tree. Note that the merging process must start from the root nodes of both trees.

### #700. Search in a Binary Search Tree
**Problem:** You are given the `root` of a binary search tree (BST) and an integer `val`. Find the node in the BST that has the value equal to `val` and return the subtree rooted with that node. If such a node does not exist, return `null`.

### #98. Validate Binary Search Tree
**Problem:** Given the `root` of a binary tree, determine if it is a valid binary search tree (BST). A valid BST is defined as follows:
- The left subtree of a node contains only nodes with keys less than the node's key.
- The right subtree of a node contains only nodes with keys greater than the node's key.
- Both the left and right subtrees must also be binary search trees.

### #530. Minimum Absolute Difference in BST
**Problem:** Given the `root` of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.

### #501. Find Mode in Binary Search Tree
**Problem:** Given the `root` of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it. If the tree has more than one mode, return them in any order.

### #236. Lowest Common Ancestor of a Binary Tree
**Problem:** Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree. According to the definition of LCA on Wikipedia: "The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself)."

### #701. Insert into a Binary Search Tree
**Problem:** You are given the root node of a binary search tree (BST) and a value to insert into the tree. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

There may be multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

### #450. Delete Node in a BST
**Problem:** Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

### #108. Convert Sorted Array to Binary Search Tree
**Problem:** Given an integer array `nums` where the elements are sorted in ascending order, convert it to a height-balanced binary search tree. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.

### #669. Trim a Binary Search Tree
**Problem:** Given the `root` of a binary search tree and the lowest and highest boundaries as `low` and `high`, trim the tree so that all its elements lie in `[low, high]`. Trimming the tree should not change the relative structure of the elements that remain in the tree. Return the root of the trimmed binary search tree.
\n### #216. Combination Sum III\n**Problem:** Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n- Only numbers 1 through 9 are used.\n- Each number is used at most once.\n- Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\n

### #17. Letter Combinations of a Phone Number
**Problem:** Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order. A mapping of digits to letters is similar to a telephone keypad.


### #39. Combination Sum
**Problem:** Given an array of distinct integers `candidates` and a target integer `target`, return a list of all unique combinations of candidates where the chosen numbers sum to `target`. You may return the combinations in any order. The same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.


### #40. Combination Sum II
**Problem:** Given a collection of candidate numbers () and a target number (), find all unique combinations in  where the candidate numbers sum to . Each number in  may only be used once in the combination. The solution set must not contain duplicate combinations.


### #40. Combination Sum II
**Problem:** Given a collection of candidate numbers () and a target number (), find all unique combinations in  where the candidate numbers sum to . Each number in  may only be used once in the combination. The solution set must not contain duplicate combinations.

### #40. Combination Sum II
**Problem:** Given a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`. Each number in `candidates` may only be used once in the combination. The solution set must not contain duplicate combinations.

### #46. Permutations
**Problem:** Given an array `nums` of distinct integers, return all the possible permutations. You can return the answer in any order.

### #47. Permutations II
**Problem:** Given a collection of numbers that might contain duplicates, return all possible unique permutations in any order.

### #78. Subsets
**Problem:** Given an integer array `nums` of unique elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.


### #93. Restore IP Addresses
**Problem:** Given a string containing only digits, restore it by returning all possible valid IP address combinations. A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.

### #90. Subsets II
**Problem:** Given an integer array `nums` that may contain duplicates, return all possible subsets (the power set). The solution set must not contain duplicate subsets. Return the solution in any order.

### #131. Palindrome Partitioning
**Problem:** Given a string `s`, partition `s` such that every substring of the partition is a palindrome. Return all possible palindrome partitioning of `s`.

### #491. Non-decreasing Subsequences
**Problem:** Given an integer array `nums`, return all the different possible non-decreasing subsequences of the given array with at least two elements. You may return the answer in any order.

### #37. Sudoku Solver
**Problem:** Write a program to solve a Sudoku puzzle by filling the empty cells.
A sudoku solution must satisfy all of the following rules:
- Each of the digits 1-9 must occur exactly once in each row.
- Each of the digits 1-9 must occur exactly once in each column.
- Each of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.
The '.' character indicates empty cells.

### #51. N-Queens
**Problem:** The n-queens puzzle is the problem of placing n queens on an n x n chessboard such that no two queens attack each other. Given an integer n, return all distinct solutions to the n-queens puzzle. Each solution represents a distinct board configuration where 'Q' indicates a queen and '.' indicates an empty space.

### #455. Assign Cookies
**Problem:** Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie. Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with; and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i, and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.

### #376. Wiggle Subsequence
**Problem:** Given an integer array `nums`, return the length of the longest wiggle subsequence of `nums`. A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. For example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) are alternately positive and negative. A subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.