# LeetCode Problems Summary

This file provides a brief overview of the LeetCode problems implemented in this project.

---

### #1. Two Sum
**Problem:** Given an array of integers `nums` and an integer `target`, return the indices of the two numbers such that they add up to `target`.

### #15. 3Sum
**Problem:** Given an integer array `nums`, return all unique triplets `[nums[i], nums[j], nums[k]]` such that `i != j != k` and their sum is `0`.

### #19. Remove Nth Node From End of List
**Problem:** Given the `head` of a linked list, remove the `n`-th node from the end of the list and return its head.

### #27. Remove Element
**Problem:** Given an integer array `nums` and an integer `val`, remove all occurrences of `val` in `nums` in-place and return the number of elements remaining.

### #42. Trapping Rain Water
**Problem:** Given `n` non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.

### #28. Find the Index of the First Occurrence in a String
**Problem:** Given two strings, `needle` and `haystack`, return the index of the first occurrence of `needle` in `haystack`, or `-1` if `needle` is not part of `haystack`.

### #59. Spiral Matrix II
**Problem:** Given a positive integer `n`, generate an `n x n` matrix filled with elements from `1` to `n^2` in spiral order.

### #142. Linked List Cycle II
**Problem:** Given the `head` of a linked list, return the node where the cycle begins. If there is no cycle, return `null`.

### #151. Reverse Words in a String
**Problem:** Given an input string `s`, reverse the order of the words. The returned string should have a single space separating the words, with no extra spaces.

### #203. Remove Linked List Elements
**Problem:** Given the `head` of a linked list and an integer `val`, remove all nodes of the linked list that have `Node.val == val`, and return the new head.

### #206. Reverse Linked List
**Problem:** Given the `head` of a singly linked list, reverse the list and return the reversed list.

### #209. Minimum Size Subarray Sum
**Problem:** Given an array of positive integers `nums` and a positive integer `target`, return the minimal length of a subarray whose sum is greater than or equal to `target`. If no such subarray exists, return `0`.

### #242. Valid Anagram
**Problem:** Given two strings `s` and `t`, return `true` if `t` is an anagram of `s`, and `false` otherwise.

### #344. Reverse String
**Problem:** Write a a function that reverses a string. The input string is given as an array of characters `s`. You must do this by modifying the input array in-place with O(1) extra memory.

### #349. Intersection of Two Arrays
**Problem:** Given two integer arrays `nums1` and `nums2`, return an array of their intersection. Each element in the result must be unique.

### #452. Minimum Number of Arrows to Burst Balloons
**Problem:** Given an array of points where `points[i] = [xstart, xend]`, return the minimum number of arrows that must be shot to burst all balloons. An arrow shot at `x` bursts a balloon if `xstart <= x <= end`.

### #454. 4Sum II
**Problem:** Given four integer arrays `nums1`, `nums2`, `nums3`, and `nums4`, return the number of tuples `(i, j, k, l)` such that `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`.

### #541. Reverse String II
**Problem:** Given a string `s` and an integer `k`, for every `2k` characters, reverse the first `k` characters. Handle edge cases with remaining characters.

### #707. Design Linked List
**Problem:** Design and implement a `MyLinkedList` class that supports `get`, `addAtHead`, `addAtTail`, `addAtIndex`, and `deleteAtIndex` operations for both singly and doubly linked lists.

### #459. Repeated Substring Pattern
**Problem:** Given a non-empty string `s`, determine if it can be constructed by taking a substring of it and appending multiple copies of the substring together.

### #232. Implement Queue using Stacks
**Problem:** Implement a First-In-First-Out (FIFO) queue using only two stacks. The implemented queue must support all the standard queue operations: `push`, `pop`, `peek`, and `empty`.

### #225. Implement Stack using Queues
**Problem:** Implement a Last-In-First-Out (LIFO) stack using only one or two queues. The implemented stack must support all the standard stack operations: `push`, `top`, `pop`, and `empty`.

### #20. Valid Parentheses
**Problem:** Given a string `s` containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets and in the correct order.

### #150. Evaluate Reverse Polish Notation
**Problem:** Given an array of strings `tokens` that represents an arithmetic expression in Reverse Polish Notation, evaluate the expression and return its integer value. The valid operators are `+`, `-`, `*`, `/`, and division truncates toward zero.

### #145. Binary Tree Postorder Traversal
**Problem:** Given the `root` of a binary tree, return the postorder traversal of its nodes' values.

### #239. Sliding Window Maximum
**Problem:** You are given an array of integers `nums` and an integer `k`. A sliding window of size `k` moves from the very left to the very right of the array. Return an array of the maximum values found in each window.

### #347. Top K Frequent Elements
**Problem:** Given an integer array `nums` and an integer `k`, return the `k` most frequent elements. You may return the answer in any order.

### #94. Binary Tree Inorder Traversal
**Problem:** Given the `root` of a binary tree, return the inorder traversal of its nodes' values.

### #144. Binary Tree Preorder Traversal
**Problem:** Given the `root` of a binary tree, return the preorder traversal of its nodes' values.

### #102. Binary Tree Level Order Traversal
**Problem:** Given the `root` of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

### #101. Symmetric Tree
**Problem:** Given the `root` of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).

### #104. Maximum Depth of Binary Tree
**Problem:** Given the `root` of a binary tree, return its maximum depth. A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

### #111. Minimum Depth of Binary Tree
**Problem:** Given a binary tree, find its minimum depth. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf is a node with no children.

### #226. Invert Binary Tree
**Problem:** Given the `root` of a binary tree, invert the tree, and return its root. Inverting a binary tree means swapping every node's left and right children recursively throughout the tree.

### #110. Balanced Binary Tree
**Problem:** Given a binary tree, determine if it is height-balanced. A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differs by more than one.

### #257. Binary Tree Paths
**Problem:** Given the `root` of a binary tree, return all root-to-leaf paths in any order. A leaf is a node with no children.

### #106. Construct Binary Tree from Inorder and Postorder Traversal
**Problem:** Given two integer arrays `inorder` and `postorder`, where `inorder` is the inorder traversal of a binary tree and `postorder` is the postorder traversal of the same tree, construct and return the binary tree.

### #112. Path Sum
**Problem:** Given the `root` of a binary tree and an integer `targetSum`, return `true` if the tree has a root-to-leaf path such that the sum of all values along the path equals `targetSum`. A leaf is a node with no children.
